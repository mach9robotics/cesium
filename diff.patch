diff --git a/packages/engine/Source/Scene/Model/Model.js b/packages/engine/Source/Scene/Model/Model.js
index 3b64dd296b..a9986d908d 100644
--- a/packages/engine/Source/Scene/Model/Model.js
+++ b/packages/engine/Source/Scene/Model/Model.js
@@ -1967,7 +1967,7 @@ function processLoader(model, frameState) {
   if (!model._resourcesLoaded || !model._texturesLoaded) {
     // Ensures frames continue to render in requestRender mode while resources are processing
     frameState.afterRender.push(() => true);
-    return model._loader.process(frameState);
+    return model._loader.process(frameState, model.referenceMatrix);
   }
 
   return true;
diff --git a/packages/engine/Source/Scene/Model/PntsLoader.js b/packages/engine/Source/Scene/Model/PntsLoader.js
index 2565dd01a4..e77defa3dc 100644
--- a/packages/engine/Source/Scene/Model/PntsLoader.js
+++ b/packages/engine/Source/Scene/Model/PntsLoader.js
@@ -23,6 +23,7 @@ import ModelComponents from "../ModelComponents.js";
 import PntsParser from "../PntsParser.js";
 import ResourceLoaderState from "../ResourceLoaderState.js";
 import VertexAttributeSemantic from "../VertexAttributeSemantic.js";
+import Transforms from "../../Core/Transforms.js";
 
 const Components = ModelComponents.Components;
 const Scene = ModelComponents.Scene;
@@ -64,6 +65,11 @@ function PntsLoader(options) {
   this._parsedContent = undefined;
   this._decodePromise = undefined;
   this._decodedAttributes = undefined;
+  this._indexedTree = undefined;
+  this._transformationMatrix = undefined;
+  this._rtcCenter = undefined;
+  this._pointsLength = undefined;
+  this._ecefRefPoint = undefined;
 
   this._promise = undefined;
   this._error = undefined;
@@ -73,6 +79,8 @@ function PntsLoader(options) {
   // The batch table object contains a json and a binary component access using keys of the same name.
   this._components = undefined;
   this._transform = Matrix4.IDENTITY;
+
+  this.test_variable = [];
 }
 
 if (defined(Object.create)) {
@@ -144,7 +152,7 @@ PntsLoader.prototype.load = function () {
   this._promise = Promise.resolve(this);
 };
 
-PntsLoader.prototype.process = function (frameState) {
+PntsLoader.prototype.process = function (frameState, transformationMatrix) {
   if (defined(this._error)) {
     const error = this._error;
     this._error = undefined;
@@ -159,7 +167,7 @@ PntsLoader.prototype.process = function (frameState) {
     if (defined(this._decodePromise)) {
       return false;
     }
-
+    this._transformationMatrix = transformationMatrix;
     this._decodePromise = decodeDraco(this, frameState.context);
   }
 
@@ -572,6 +580,59 @@ function makeStructuralMetadata(parsedContent, customAttributeOutput) {
   });
 }
 
+// Function to make a 2d tree based on the x y coordinates of points
+// positions should be a Float32 Array in the form [x1, y1, z1, x2, y2, z2, ...]
+// Output will be an Int32 Array in the form [l1, r1, l2, r2, ...]
+// Where each (l, r) value will correspond to the respective point in the positions array e.g. (li, ri) <=> (xi, yi. zi)
+// l represents the index of the point's left child, and r represents the index of the points right child.
+// If l = 0, then the point does not have a left child, similarly if r = 0 then there is no right child
+function make2DTree(positions) {
+  //assert(positions.length % 3 === 0);
+  const numberOfPoints = positions.length / 3;
+  const indexedTree = new Int32Array(numberOfPoints * 2);
+  for (let i = 1; i < numberOfPoints; i++) {
+    // Root node will always be at index 0
+    let curNode = 0;
+    let depth = 1;
+    while (depth < numberOfPoints) {
+      const curx = positions[curNode * 3];
+      const cury = positions[curNode * 3 + 1];
+      // Split by y
+      if (depth % 2 === 0) {
+        if (positions[i * 3 + 1] <= cury) {
+          if (indexedTree[curNode * 2] === 0) {
+            indexedTree[curNode * 2] = i;
+            break;
+          } else {
+            curNode = indexedTree[curNode * 2];
+          }
+        } else if (indexedTree[curNode * 2 + 1] === 0) {
+          indexedTree[curNode * 2 + 1] = i;
+          break;
+        } else {
+          curNode = indexedTree[curNode * 2 + 1];
+        }
+      }
+      // Split by x
+      else if (positions[i * 3] <= curx) {
+        if (indexedTree[curNode * 2] === 0) {
+          indexedTree[curNode * 2] = i;
+          break;
+        } else {
+          curNode = indexedTree[curNode * 2];
+        }
+      } else if (indexedTree[curNode * 2 + 1] === 0) {
+        indexedTree[curNode * 2 + 1] = i;
+        break;
+      } else {
+        curNode = indexedTree[curNode * 2 + 1];
+      }
+    }
+    depth++;
+  }
+  return indexedTree;
+}
+
 function makeComponents(loader, context) {
   const parsedContent = loader._parsedContent;
 
@@ -660,12 +721,56 @@ function makeComponents(loader, context) {
   }
 
   loader._components = components;
-
-  // Free the parsed content and array buffer so we don't hold onto the large arrays.
+  loader._rtcCenter = parsedContent.rtcCenter;
+  loader._pointsLength = parsedContent.pointsLength;
+  loader._enuCoords = new Float64Array(3 * loader._pointsLength);
+  loader._ecefRefPoint = Matrix4.multiplyByPoint(
+    loader._transformationMatrix,
+    loader._rtcCenter,
+    new Cartesian3()
+  );
+  const enuTransformationMatrix = Matrix4.inverseTransformation(
+    Transforms.eastNorthUpToFixedFrame(loader._ecefRefPoint),
+    new Matrix4()
+  );
+  for (let i = 0; i < loader._pointsLength; i++) {
+    const x = positions.typedArray[3 * i] + loader._rtcCenter.x;
+    const y = positions.typedArray[3 * i + 1] + loader._rtcCenter.y;
+    const z = positions.typedArray[3 * i + 2] + loader._rtcCenter.z;
+    const ecefCoords = matrixMultbyPoint(loader._transformationMatrix, x, y, z);
+    const enuCoords = matrixMultbyPointasVec(
+      enuTransformationMatrix,
+      ecefCoords[0] - loader._ecefRefPoint.x,
+      ecefCoords[1] - loader._ecefRefPoint.y,
+      ecefCoords[2] - loader._ecefRefPoint.z
+    );
+    loader._enuCoords[3 * i] = enuCoords[0];
+    loader._enuCoords[3 * i + 1] = enuCoords[1];
+    loader._enuCoords[3 * i + 2] = enuCoords[2];
+  }
+  loader._indexedTree = make2DTree(loader._enuCoords);
   loader._parsedContent = undefined;
   loader._arrayBuffer = undefined;
 }
 
+function matrixMultbyPoint(matrix, vX, vY, vZ) {
+  const ecef = new Float64Array(3);
+  ecef[0] = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12];
+  ecef[1] = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13];
+  ecef[2] = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14];
+  return ecef;
+}
+
+function matrixMultbyPointasVec(matrix, vX, vY, vZ) {
+  const enu = new Float64Array(3);
+  enu[0] = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ;
+  enu[1] = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ;
+  enu[2] = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ;
+  return enu;
+}
+
+PntsLoader.prototype.drillPickWithRay = function (ray) {};
+
 function addPropertyAttributesToPrimitive(
   loader,
   primitive,
diff --git a/packages/engine/Source/Scene/Scene.js b/packages/engine/Source/Scene/Scene.js
index df6fe479cf..fabf6235ae 100644
--- a/packages/engine/Source/Scene/Scene.js
+++ b/packages/engine/Source/Scene/Scene.js
@@ -4099,6 +4099,10 @@ Scene.prototype.drillPickFromRay = function (
   );
 };
 
+Scene.prototype.getVerticalIntersection = function (point, width) {
+  return this._picking.getVerticalIntersection(this, point, width);
+};
+
 /**
  * Initiates an asynchronous {@link Scene#pickFromRay} request using the maximum level of detail for 3D Tilesets
  * regardless of visibility.
